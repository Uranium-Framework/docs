{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Welcome to the official website for Sunrise Framework, if you are looking for a documentation on how to use the framework you are in the correct place! Anyways lets get this doc started! You can find what you are looking for in the Getting Started section! Note To find these extensions, you can either visit our discord or find some creator verified ones here Getting started \u00b6 Installation Documentation API References Releases What is Sunrise Framework? \u00b6 Why Sunrise Framework? \u00b6 Installation \u00b6 There are multiple ways to install Project Sunrise! Read on to find out all of the current methods: Make sure to get the libraries and The Project Sunrise it self from the marketplace! While not all methods require roblox asset insertion it is still recommended to get the libraries as well as the framework it self just incase you wish to use the commands that come with the framework! Roblox Marketplace \u00b6 You can pick up the module from the Roblox Marketplace . While this is a good method of installation, you have to place everything in the correct places on your own. Please refer to the docs in order to place everything correctly! Bootstrapper \u00b6 A good and easy way to install Project Sunrise is to use the following code into the roblox command bar, this however may have some complications as stated below!. local httpservice = game:GetService(\"HttpService\") local enabled = httpservice.HttpEnabled httpservice.HttpEnabled = true loadstring(httpservice:GetAsync(\"https://raw.githubusercontent.com/SyntalDev/Project-Sunrise/main/install.lua\"))(enabled) Some manual action required This method requires you to simply purchase( THIS DOES NOT COST ANYTHING! ) our libraries model. Otherwise the framework will not have any libraries!","title":"Home"},{"location":"#introduction","text":"Welcome to the official website for Sunrise Framework, if you are looking for a documentation on how to use the framework you are in the correct place! Anyways lets get this doc started! You can find what you are looking for in the Getting Started section! Note To find these extensions, you can either visit our discord or find some creator verified ones here","title":"Introduction"},{"location":"#getting-started","text":"Installation Documentation API References Releases","title":"Getting started"},{"location":"#what-is-sunrise-framework","text":"","title":"What is Sunrise Framework?"},{"location":"#why-sunrise-framework","text":"","title":"Why Sunrise Framework?"},{"location":"#installation","text":"There are multiple ways to install Project Sunrise! Read on to find out all of the current methods: Make sure to get the libraries and The Project Sunrise it self from the marketplace! While not all methods require roblox asset insertion it is still recommended to get the libraries as well as the framework it self just incase you wish to use the commands that come with the framework!","title":"Installation"},{"location":"#roblox-marketplace","text":"You can pick up the module from the Roblox Marketplace . While this is a good method of installation, you have to place everything in the correct places on your own. Please refer to the docs in order to place everything correctly!","title":"Roblox Marketplace"},{"location":"#bootstrapper","text":"A good and easy way to install Project Sunrise is to use the following code into the roblox command bar, this however may have some complications as stated below!. local httpservice = game:GetService(\"HttpService\") local enabled = httpservice.HttpEnabled httpservice.HttpEnabled = true loadstring(httpservice:GetAsync(\"https://raw.githubusercontent.com/SyntalDev/Project-Sunrise/main/install.lua\"))(enabled) Some manual action required This method requires you to simply purchase( THIS DOES NOT COST ANYTHING! ) our libraries model. Otherwise the framework will not have any libraries!","title":"Bootstrapper"},{"location":"Releases/","text":"Versions \u00b6 Luna(Generation 1) \u00b6 1.0.0-alpha1 - (Information) \u00b6 Community Made \u00b6 non available!","title":"Releases"},{"location":"Releases/#versions","text":"","title":"Versions"},{"location":"Releases/#lunageneration-1","text":"","title":"Luna(Generation 1)"},{"location":"Releases/#100-alpha1-information","text":"","title":"1.0.0-alpha1 - (Information)"},{"location":"Releases/#community-made","text":"non available!","title":"Community Made"},{"location":"TweenStyles/","text":"Tween \u00b6 Tween styles \u00b6 { \"Linear\", \"Quad\", \"Cubic\", \"Quart\", \"Quint\", \"Sine\", \"Expo\", \"Circ\", \"Elastic\", \"Back\", \"Bounce\", \"Smooth\", \"Smoother\", \"RidiculousWiggle\", \"RevBack\", \"Spring\", \"SoftSpring\", \"Standard\", \"Sharp\", \"Acceleration\", \"Deceleration\", \"StandardProductive\", \"EntranceProductive\", \"ExitProductive\", \"StandardExpressive\", \"EntranceExpressive\", \"ExitExpressive\", \"FabricStandard\", \"FabricAccelerate\", \"FabricDecelerate\", \"UWPAccelerate\", \"MozillaCurve\" } Tween directions \u00b6 { \"In\", \"Out\", \"InOut\" } Tween StepTypes \u00b6 StepTypes are a RunService event desgined to fire at different times { \"Heartbeat\", --Fires every frame after the physics simulation has completed(Dont worry about this too much! It pretty much just runs everytime you move your character!) \"RenderStepped\", --Fires every frame prior to the frame being rendered(This means that it will constantly run, this will run before Heartbeat!) \"Stepped\" --Fires every frame prior to the physics simulation(This is also fatser than Heartbeat and it does the opposite of Heartbeat) }","title":"Tween"},{"location":"TweenStyles/#tween","text":"","title":"Tween"},{"location":"TweenStyles/#tween-styles","text":"{ \"Linear\", \"Quad\", \"Cubic\", \"Quart\", \"Quint\", \"Sine\", \"Expo\", \"Circ\", \"Elastic\", \"Back\", \"Bounce\", \"Smooth\", \"Smoother\", \"RidiculousWiggle\", \"RevBack\", \"Spring\", \"SoftSpring\", \"Standard\", \"Sharp\", \"Acceleration\", \"Deceleration\", \"StandardProductive\", \"EntranceProductive\", \"ExitProductive\", \"StandardExpressive\", \"EntranceExpressive\", \"ExitExpressive\", \"FabricStandard\", \"FabricAccelerate\", \"FabricDecelerate\", \"UWPAccelerate\", \"MozillaCurve\" }","title":"Tween styles"},{"location":"TweenStyles/#tween-directions","text":"{ \"In\", \"Out\", \"InOut\" }","title":"Tween directions"},{"location":"TweenStyles/#tween-steptypes","text":"StepTypes are a RunService event desgined to fire at different times { \"Heartbeat\", --Fires every frame after the physics simulation has completed(Dont worry about this too much! It pretty much just runs everytime you move your character!) \"RenderStepped\", --Fires every frame prior to the frame being rendered(This means that it will constantly run, this will run before Heartbeat!) \"Stepped\" --Fires every frame prior to the physics simulation(This is also fatser than Heartbeat and it does the opposite of Heartbeat) }","title":"Tween StepTypes"},{"location":"API/Introduction/","text":"Replica Service \u00b6 Profile Service \u00b6 Top Bar \u00b6 API Section for the Top Bar library. To use this use the following API table lua local API = self.API; local TopBar = API.TopBar Warning Through out the reference for TopBar, I use terms like chained and unchained . What this means is that if something is chained it is connected to a constructor like this: lua local new = TopBar.newIcon() --Chained constuctor new:chainFunction(nil,function(icon)) --This is the constuructor chained to another function If it is unchained it does not have a constructor attached to it instead it uses a parameter All of our TopBar API section is made to accept a TopBar.rawIcon as a parameter ! lua local new = TopBar.rawIcon() --Unchained constructor meaning this cannot be chanined with other function instead it has to be passed as a parameter! TopBar:chainFunction(new, function(icon)) --This is a function that is not chained instead it uses the first parameter as the icon Constructors \u00b6 Can be chained newIcon \u00b6 local new = TopBar.newIcon(name,{}) name - string sets the name of the icon. {} - table pass in any setting to be used to style or add functions to your icon. Used to create a new Icon. This constructor takes any TopBar setting and name within the table, to search through these settings check this page out! Example: local API = self.API; local TopBar = API.TopBar; local new = TopBar.newIcon(\"Name\", { iconText = \"Hello\", iconBackgroundColor = Color3.fromRGB(96, 255, 122) }); Cannot be chained rawIcon \u00b6 local new = TopBar.rawIcon(name,{}) name - string sets the name of the icon. {} - table pass in any setting to be used to style or add functions to your icon. Used to create a new Icon. This constructor takes any TopBar setting and name within the table, to search through these settings check this page out! The only difference between this and TopBar.newIcon is that this is used to construct menus and dropdowns! Example: local API = self.API; local TopBar = API.TopBar; TopBar.rawIcon(\"Name\", { iconText = \"Hello\", iconBackgroundColor = Color3.fromRGB(96, 255, 122) }); Functions \u00b6 chainFunction \u00b6 Any:ChainFunction(Icon,function(icon)) Icon - icon instance pass TopBar.rawIcon when making menus and dropdowns, when not making a dropdown or a menu pass as nil function(icon) - function make your own code here, use icon to change anything with your current icon Adds a function to the constructed icon. The argument icon acts as the icon constructed previously, to manipulate anything make sure you use that argument. Check this for any methods, that are not included in this API! All methods from the library are compatible with the icon argument! This can also change any setting nessessary all you need to do is icon:AnyMethodFromTopBarHere!() Example: local API = self.API; local TopBar = API.TopBar; local new = TopBar.newIcon(\"Name\",{iconText = \"hi\"}); new:chainFunction(function(icon) icon.toggled:Connect(function() print(\"hello\"); end); end); Example 2: local API = self.API; local TopBar = API.TopBar; local new = TopBar.newIcon(\"Name\",{iconText = \"hi\"}); new:chainFunction(function(icon) icon:setMid(); end); Example 3(Unchained): local API = self.API; local TopBar = API.TopBar; local new = TopBar.rawIcon(\"name1\", {iconText = \"hi\"}); TopBar:chainFunction(new, function(icon) icon.toggled:Connect(function() print(\"hi\"); end); end); Methods \u00b6 notifyUser \u00b6 Any:notifyUser(Icon) Icon - icon instance pass in an icon if you are trying to send an notification to an icon made from TopBar.rawIcon otherwise set it to nil.= Creates a small bubble on the parented icon. If used on a certain icon of a dropdown or a menu it will also show the bubble on that specific icon. Example(Non-Menu): local API = self.API; local TopBar = API.TopBar; local new = TopBar.newIcon(\"Name\",{iconText = \"hi\"}); part.Touched:Connect(function(victim) new:notifyUser(); end) Example(Menu): local API = self.API; local TopBar = API.TopBar; local new = TopBar.newIcon(\"Name\",{iconText = \"hi\"}); --//Dropdown new:createDropdown({TopBar.rawIcon(\"name1\",{iconText = \"hi\"}), TopBar.rawIcon(\"name2\", {iconText = \"no\"})}); --//Notification to icon text no local current = TopBar:retrieveIcon(\"name2\") part.Touched:Connect(function() TopBar:notifyUser(current); end); retrieveIcon \u00b6 local icon = TopBar:retrieveIcon(name) name - string pass in a name of any icon made Returns an icon with the name that was passed in Example: local current = TopBar:retrieveIcon(\"name2\") part.Touched:Connect(function() TopBar:notifyUser(current); end); createDropdown \u00b6 Any:createDropdown(Icon, {}) Icon - icon instance pass in a custom icon to be the parent, if you want to use an icon made from TopBar.newIcon simply chain it by doing new:createDropDown(nil, {}) {} - table pass in multiple of new icons using TopBar.rawIcon , bare in mind TopBar.newIcon will not work with this Creates a dropdown menu using all the TopBar.rawIcon from the children table( {} ) Example 1(Chained): local API = self.API; local TopBar = API.TopBar; local new = TopBar.newIcon(\"Name\",{iconText = \"hi\"}); new:createDropdown({TopBar.rawIcon(\"name1\",{iconText = \"hi\"}), TopBar.rawIcon(\"name2\", {iconText = \"no\"})}); Example 2(Unchained): local new = TopBar.rawIcon(\"hello\", {iconText = \"hi\"}); TopBar:createDropdown( new,{TopBar.rawIcon(\"name1\",{iconText = \"yes\"}), TopBar.rawIcon(\"name2\",{iconText = \"no\"})} ); createMenu \u00b6 Any:createMenu(Icon, {}) Icon - icon instance pass in a custom icon to be the parent, if you want to use an icon made from TopBar.newIcon simply chain it by doing new:createDropDown(nil, {}) {} - table pass in multiple of new icons using TopBar.rawIcon , bare in mind TopBar.newIcon will not work with this Creates a menu using all the TopBar.rawIcon from the children table( {} ) Example 1(Chained): local API = self.API; local TopBar = API.TopBar; local new = TopBar.newIcon(\"name\", {iconText = \"hi\"}) new:createMenu(nil, { TopBar.rawIcon(\"name2\", {iconText = \"no\"}) }); Example 2(Unchained): local API = self.API; local TopBar = API.TopBar; local new = TopBar.rawIcon(\"name\", {iconText = \"hi\"}) TopBar:createMenu(new, { TopBar.rawIcon(\"name2\", {iconText = \"no\"}) }); Bezier \u00b6 Tween \u00b6 API Section for Tween. To use this use the following API table lua local API = self.API; local Tween = API.Tween Constructors \u00b6 new \u00b6 local new = Tween.new({}) {} - table pass in the data for the tween to use. BoatTween has many new styles to pick and choose from, they can he found here Creates and returns a new tween from all the setting passed into {} Example - local API = self.API; local Tween = API.Tween; local part = workspace.Part; local new = Tween.new({ obj = part, --This is the instance you want the tween to be aplied to, this can be anything from parts to ui. numTime = 20, --This is how long the tween will take place(in seconds). easingStyle = \"Quint\", --This is a style your tween will take. easingDirection = \"Out\", --This is a direction your tween will take. reverse = false, --This is an option to make the tween go back to it previous state(before the tween took place). delayTime = 10, --This is a time before the tween will play from being called using void:play(). repeatCount = 0, --This is how much times your tween will be repeated. stepType = \"Heartbeat\", --This is when your tween will be played. Check TweenStyles for more info on these! goal = {Transparency = 1;} --This is what you want the tween to do, there can be multiple things the tween does at once. }); Methods \u00b6 play \u00b6 new:play() Plays a created tween. Example- local API = self.API; local Tween = API.Tween; local part = workspace.Part; local new = Tween.new({ obj = part, --This is the instance you want the tween to be aplied to, this can be anything from parts to ui. numTime = 20, --This is how long the tween will take place(in seconds). easingStyle = \"Quint\", --This is a style your tween will take. easingDirection = \"Out\", --This is a direction your tween will take. reverse = false, --This is an option to make the tween go back to it previous state(before the tween took place). delayTime = 10, --This is a time before the tween will play from being called using void:play(). repeatCount = 0, --This is how much times your tween will be repeated. stepType = \"Heartbeat\", --This is when your tween will be played. Check TweenStyles for more info on these! goal = {Transparency = 1;} --This is what you want the tween to do, there can be multiple things the tween does at once. }); new:play(); -- :play() needs to be connected to a Tween.new() constructor via the new variable(This variable can be changed just make sure to connect :play() to it!) Roact \u00b6 Promise \u00b6","title":"Introduction"},{"location":"API/Introduction/#replica-service","text":"","title":"Replica Service"},{"location":"API/Introduction/#profile-service","text":"","title":"Profile Service"},{"location":"API/Introduction/#top-bar","text":"API Section for the Top Bar library. To use this use the following API table lua local API = self.API; local TopBar = API.TopBar Warning Through out the reference for TopBar, I use terms like chained and unchained . What this means is that if something is chained it is connected to a constructor like this: lua local new = TopBar.newIcon() --Chained constuctor new:chainFunction(nil,function(icon)) --This is the constuructor chained to another function If it is unchained it does not have a constructor attached to it instead it uses a parameter All of our TopBar API section is made to accept a TopBar.rawIcon as a parameter ! lua local new = TopBar.rawIcon() --Unchained constructor meaning this cannot be chanined with other function instead it has to be passed as a parameter! TopBar:chainFunction(new, function(icon)) --This is a function that is not chained instead it uses the first parameter as the icon","title":"Top Bar"},{"location":"API/Introduction/#constructors","text":"Can be chained","title":"Constructors"},{"location":"API/Introduction/#newicon","text":"local new = TopBar.newIcon(name,{}) name - string sets the name of the icon. {} - table pass in any setting to be used to style or add functions to your icon. Used to create a new Icon. This constructor takes any TopBar setting and name within the table, to search through these settings check this page out! Example: local API = self.API; local TopBar = API.TopBar; local new = TopBar.newIcon(\"Name\", { iconText = \"Hello\", iconBackgroundColor = Color3.fromRGB(96, 255, 122) }); Cannot be chained","title":"newIcon"},{"location":"API/Introduction/#rawicon","text":"local new = TopBar.rawIcon(name,{}) name - string sets the name of the icon. {} - table pass in any setting to be used to style or add functions to your icon. Used to create a new Icon. This constructor takes any TopBar setting and name within the table, to search through these settings check this page out! The only difference between this and TopBar.newIcon is that this is used to construct menus and dropdowns! Example: local API = self.API; local TopBar = API.TopBar; TopBar.rawIcon(\"Name\", { iconText = \"Hello\", iconBackgroundColor = Color3.fromRGB(96, 255, 122) });","title":"rawIcon"},{"location":"API/Introduction/#functions","text":"","title":"Functions"},{"location":"API/Introduction/#chainfunction","text":"Any:ChainFunction(Icon,function(icon)) Icon - icon instance pass TopBar.rawIcon when making menus and dropdowns, when not making a dropdown or a menu pass as nil function(icon) - function make your own code here, use icon to change anything with your current icon Adds a function to the constructed icon. The argument icon acts as the icon constructed previously, to manipulate anything make sure you use that argument. Check this for any methods, that are not included in this API! All methods from the library are compatible with the icon argument! This can also change any setting nessessary all you need to do is icon:AnyMethodFromTopBarHere!() Example: local API = self.API; local TopBar = API.TopBar; local new = TopBar.newIcon(\"Name\",{iconText = \"hi\"}); new:chainFunction(function(icon) icon.toggled:Connect(function() print(\"hello\"); end); end); Example 2: local API = self.API; local TopBar = API.TopBar; local new = TopBar.newIcon(\"Name\",{iconText = \"hi\"}); new:chainFunction(function(icon) icon:setMid(); end); Example 3(Unchained): local API = self.API; local TopBar = API.TopBar; local new = TopBar.rawIcon(\"name1\", {iconText = \"hi\"}); TopBar:chainFunction(new, function(icon) icon.toggled:Connect(function() print(\"hi\"); end); end);","title":"chainFunction"},{"location":"API/Introduction/#methods","text":"","title":"Methods"},{"location":"API/Introduction/#notifyuser","text":"Any:notifyUser(Icon) Icon - icon instance pass in an icon if you are trying to send an notification to an icon made from TopBar.rawIcon otherwise set it to nil.= Creates a small bubble on the parented icon. If used on a certain icon of a dropdown or a menu it will also show the bubble on that specific icon. Example(Non-Menu): local API = self.API; local TopBar = API.TopBar; local new = TopBar.newIcon(\"Name\",{iconText = \"hi\"}); part.Touched:Connect(function(victim) new:notifyUser(); end) Example(Menu): local API = self.API; local TopBar = API.TopBar; local new = TopBar.newIcon(\"Name\",{iconText = \"hi\"}); --//Dropdown new:createDropdown({TopBar.rawIcon(\"name1\",{iconText = \"hi\"}), TopBar.rawIcon(\"name2\", {iconText = \"no\"})}); --//Notification to icon text no local current = TopBar:retrieveIcon(\"name2\") part.Touched:Connect(function() TopBar:notifyUser(current); end);","title":"notifyUser"},{"location":"API/Introduction/#retrieveicon","text":"local icon = TopBar:retrieveIcon(name) name - string pass in a name of any icon made Returns an icon with the name that was passed in Example: local current = TopBar:retrieveIcon(\"name2\") part.Touched:Connect(function() TopBar:notifyUser(current); end);","title":"retrieveIcon"},{"location":"API/Introduction/#createdropdown","text":"Any:createDropdown(Icon, {}) Icon - icon instance pass in a custom icon to be the parent, if you want to use an icon made from TopBar.newIcon simply chain it by doing new:createDropDown(nil, {}) {} - table pass in multiple of new icons using TopBar.rawIcon , bare in mind TopBar.newIcon will not work with this Creates a dropdown menu using all the TopBar.rawIcon from the children table( {} ) Example 1(Chained): local API = self.API; local TopBar = API.TopBar; local new = TopBar.newIcon(\"Name\",{iconText = \"hi\"}); new:createDropdown({TopBar.rawIcon(\"name1\",{iconText = \"hi\"}), TopBar.rawIcon(\"name2\", {iconText = \"no\"})}); Example 2(Unchained): local new = TopBar.rawIcon(\"hello\", {iconText = \"hi\"}); TopBar:createDropdown( new,{TopBar.rawIcon(\"name1\",{iconText = \"yes\"}), TopBar.rawIcon(\"name2\",{iconText = \"no\"})} );","title":"createDropdown"},{"location":"API/Introduction/#createmenu","text":"Any:createMenu(Icon, {}) Icon - icon instance pass in a custom icon to be the parent, if you want to use an icon made from TopBar.newIcon simply chain it by doing new:createDropDown(nil, {}) {} - table pass in multiple of new icons using TopBar.rawIcon , bare in mind TopBar.newIcon will not work with this Creates a menu using all the TopBar.rawIcon from the children table( {} ) Example 1(Chained): local API = self.API; local TopBar = API.TopBar; local new = TopBar.newIcon(\"name\", {iconText = \"hi\"}) new:createMenu(nil, { TopBar.rawIcon(\"name2\", {iconText = \"no\"}) }); Example 2(Unchained): local API = self.API; local TopBar = API.TopBar; local new = TopBar.rawIcon(\"name\", {iconText = \"hi\"}) TopBar:createMenu(new, { TopBar.rawIcon(\"name2\", {iconText = \"no\"}) });","title":"createMenu"},{"location":"API/Introduction/#bezier","text":"","title":"Bezier"},{"location":"API/Introduction/#tween","text":"API Section for Tween. To use this use the following API table lua local API = self.API; local Tween = API.Tween","title":"Tween"},{"location":"API/Introduction/#constructors_1","text":"","title":"Constructors"},{"location":"API/Introduction/#new","text":"local new = Tween.new({}) {} - table pass in the data for the tween to use. BoatTween has many new styles to pick and choose from, they can he found here Creates and returns a new tween from all the setting passed into {} Example - local API = self.API; local Tween = API.Tween; local part = workspace.Part; local new = Tween.new({ obj = part, --This is the instance you want the tween to be aplied to, this can be anything from parts to ui. numTime = 20, --This is how long the tween will take place(in seconds). easingStyle = \"Quint\", --This is a style your tween will take. easingDirection = \"Out\", --This is a direction your tween will take. reverse = false, --This is an option to make the tween go back to it previous state(before the tween took place). delayTime = 10, --This is a time before the tween will play from being called using void:play(). repeatCount = 0, --This is how much times your tween will be repeated. stepType = \"Heartbeat\", --This is when your tween will be played. Check TweenStyles for more info on these! goal = {Transparency = 1;} --This is what you want the tween to do, there can be multiple things the tween does at once. });","title":"new"},{"location":"API/Introduction/#methods_1","text":"","title":"Methods"},{"location":"API/Introduction/#play","text":"new:play() Plays a created tween. Example- local API = self.API; local Tween = API.Tween; local part = workspace.Part; local new = Tween.new({ obj = part, --This is the instance you want the tween to be aplied to, this can be anything from parts to ui. numTime = 20, --This is how long the tween will take place(in seconds). easingStyle = \"Quint\", --This is a style your tween will take. easingDirection = \"Out\", --This is a direction your tween will take. reverse = false, --This is an option to make the tween go back to it previous state(before the tween took place). delayTime = 10, --This is a time before the tween will play from being called using void:play(). repeatCount = 0, --This is how much times your tween will be repeated. stepType = \"Heartbeat\", --This is when your tween will be played. Check TweenStyles for more info on these! goal = {Transparency = 1;} --This is what you want the tween to do, there can be multiple things the tween does at once. }); new:play(); -- :play() needs to be connected to a Tween.new() constructor via the new variable(This variable can be changed just make sure to connect :play() to it!)","title":"play"},{"location":"API/Introduction/#roact","text":"","title":"Roact"},{"location":"API/Introduction/#promise","text":"","title":"Promise"},{"location":"API/Client/bezier/","text":"","title":"Bezier"},{"location":"API/Client/GUI/icon/","text":"","title":"Icon"},{"location":"API/Client/GUI/roact/","text":"","title":"Roact"},{"location":"API/Server/profileService/","text":"Test \u00b6 Test 1 - \u00b6 Test 2 \u00b6","title":"ProfileService"},{"location":"API/Server/profileService/#test","text":"","title":"Test"},{"location":"API/Server/profileService/#test-1-","text":"","title":"Test 1 -"},{"location":"API/Server/profileService/#test-2","text":"","title":"Test 2"},{"location":"API/Server/replicaService/","text":"Test \u00b6 Test 1 - \u00b6 Test 2 \u00b6","title":"ReplicaService"},{"location":"API/Server/replicaService/#test","text":"","title":"Test"},{"location":"API/Server/replicaService/#test-1-","text":"","title":"Test 1 -"},{"location":"API/Server/replicaService/#test-2","text":"","title":"Test 2"},{"location":"API/Shared/Assets/","text":"","title":"AssetManagement"},{"location":"Documentation/SetUp/","text":"Setup \u00b6 Roblox Marketplace Install \u00b6 One of the main installation methods is the marketplace however you need to place everything in the correct place! No worries the image below will show you just where everything is! Settings \u00b6 Settings are used to customize your experience with Project Sunrise. Knit Usage \u00b6 This framework can also be used with Knit . In order to use Knit, you will need to turn the isUsingKnit option to true. Example: local settings = { isUsingKnit = true; --... Other Settings } return settings Extension \u00b6 Extensions are an organized way of requiring our libraries. They help avoid the hassel of having to require modules for every script. In order to Initialize an Extension you must use the Exends table inside of Settings. local settings = { --... Other Settings Extends = { ExampleExtension = true; -- \"true\" means Client Exposed, \"false\" means only Server }; } return settings API Usage \u00b6 This section explains how to use and modify Project Sunrise to help developers customize the framework to their wants and needs. Expansions \u00b6 Expansions are used as scripts, they help to organize the workspace evnironment. You can make an expansion by using our plugin or use this template: local self = { Name = \"test2\", -- The name of the expansion LoaderVersion = \"1.0.0\", -- Version of the Framework Loader Path = \"Server\", -- \"Server\", \"Client\", or \"Both\" Extends = { Print = true; -- [\"NameOfLibrary\"] = true } -- Extensions }; function self:Execute() -- Runs Automatically print(\"Hello World\"); end; return self; As in the Extensions Catagory, we have had to initialize the etxensions. Now we need to tell our handler that we want to use an extension in our expansion. Therefore, we need to make another Extends table in our Expansion, as seen above. Using the API \u00b6 Like any other framework Project Sunrise has a nicely constructed API, but to actually use it we need to first get it into our expansion, the example below will show you a couple of methods how you can get the API into your expansion. local self = { Name = \"test2\", -- The name of the expansion LoaderVersion = \"1.0.0\", -- Version of the Framework Loader Path = \"Server\", -- \"Server\", \"Client\", or \"Both\" Extends = { Print = true; -- [\"NameOfLibrary\"] = true } -- Extensions } function self:Execute() local API = self.API.*YourTableHere* --Our API is separate into multiple tables, each table and its function will be provided in --API References! API:APIFUNCTIONHERE() --This will run a certain function within the table of the API self.API.*YourTableHere*:APIFUNCTIONHERE() --This is another way you can run an API function, this does not use a variable! end return self The self keyword As you can see we use the self keyword. What this does is it allows to pull any external sources like the API or Extensions","title":"SetUp"},{"location":"Documentation/SetUp/#setup","text":"","title":"Setup"},{"location":"Documentation/SetUp/#roblox-marketplace-install","text":"One of the main installation methods is the marketplace however you need to place everything in the correct place! No worries the image below will show you just where everything is!","title":"Roblox Marketplace Install"},{"location":"Documentation/SetUp/#settings","text":"Settings are used to customize your experience with Project Sunrise.","title":"Settings"},{"location":"Documentation/SetUp/#knit-usage","text":"This framework can also be used with Knit . In order to use Knit, you will need to turn the isUsingKnit option to true. Example: local settings = { isUsingKnit = true; --... Other Settings } return settings","title":"Knit Usage"},{"location":"Documentation/SetUp/#extension","text":"Extensions are an organized way of requiring our libraries. They help avoid the hassel of having to require modules for every script. In order to Initialize an Extension you must use the Exends table inside of Settings. local settings = { --... Other Settings Extends = { ExampleExtension = true; -- \"true\" means Client Exposed, \"false\" means only Server }; } return settings","title":"Extension"},{"location":"Documentation/SetUp/#api-usage","text":"This section explains how to use and modify Project Sunrise to help developers customize the framework to their wants and needs.","title":"API Usage"},{"location":"Documentation/SetUp/#expansions","text":"Expansions are used as scripts, they help to organize the workspace evnironment. You can make an expansion by using our plugin or use this template: local self = { Name = \"test2\", -- The name of the expansion LoaderVersion = \"1.0.0\", -- Version of the Framework Loader Path = \"Server\", -- \"Server\", \"Client\", or \"Both\" Extends = { Print = true; -- [\"NameOfLibrary\"] = true } -- Extensions }; function self:Execute() -- Runs Automatically print(\"Hello World\"); end; return self; As in the Extensions Catagory, we have had to initialize the etxensions. Now we need to tell our handler that we want to use an extension in our expansion. Therefore, we need to make another Extends table in our Expansion, as seen above.","title":"Expansions"},{"location":"Documentation/SetUp/#using-the-api","text":"Like any other framework Project Sunrise has a nicely constructed API, but to actually use it we need to first get it into our expansion, the example below will show you a couple of methods how you can get the API into your expansion. local self = { Name = \"test2\", -- The name of the expansion LoaderVersion = \"1.0.0\", -- Version of the Framework Loader Path = \"Server\", -- \"Server\", \"Client\", or \"Both\" Extends = { Print = true; -- [\"NameOfLibrary\"] = true } -- Extensions } function self:Execute() local API = self.API.*YourTableHere* --Our API is separate into multiple tables, each table and its function will be provided in --API References! API:APIFUNCTIONHERE() --This will run a certain function within the table of the API self.API.*YourTableHere*:APIFUNCTIONHERE() --This is another way you can run an API function, this does not use a variable! end return self The self keyword As you can see we use the self keyword. What this does is it allows to pull any external sources like the API or Extensions","title":"Using the API"},{"location":"Documentation/Usage/","text":"Expansion usage \u00b6 In Sunrise Expansion are scripts which the Sunrise loader loads. Making expansions are very easy to add, it will also save your ServerScriptService from getting packed with scripts. Now how do you make expansions? There are 2 methods: The 1st method is doing the expansion manually, first you should know that only module scripts are accpeted by the loader anything else will be removed. First open your Sunrise framework It should look something like this, this is out-of-the-box look of Sunrise. As you can see there are a few things in the directory but we will only consentrate on Expansions . Anything in the expansion folder that is a Module Script with the native Sunrise format. Secondly create a module script script in the Expansions folder like and name it anything for simplicity I will name it test, you should have something like this: Great! Now then remember how I mentioned the Sunrise expansion format? Well now lets dive into that, open your expansion and copy and paste the following code into your expansion: local self = { Name = \"test\", -- The name of the expansion LoaderVersion = \"1.0.0\", -- Version of the Framework Loader Path = \"Server\", -- \"Server\", \"Client\", or \"Both\" Extends = {} -- Extensions }; function self:Execute() -- Runs Automatically print(\"Hello World\"); end; return self; Looks a bit complicated right? Well let me go through what everything does and get you up to speed, lets begin Lets go through the expansion datatable first as it is a very important part of the format Name - This is the name you want your expansion to be known as within the Sunrise runtime, each expansion will be regonised by the name you set in future updates. It is a good practice to set the name to the name you set the module script to, but hey its up to your preference! LoaderVersion - This as important as the Name , but why? When Sunrise framework is first initialized the loader reads all the expansions, if the LoaderVersion is not set to the same exact version as the loader then the expansion will simply be put into containment and ignored by the framework. Bare in mind that you do not have to use the exact version of the framework all you need is simply the 3 digits in my instance of it is 1.0.0 but in reality the version this tutorial is taken place is 1.0.0-alpha.1 Path - This is used to determine where your script will be ran. Sunrise loader does not load the script immediately, instead it first reads the Name , LoaderVersion and Path it is then correctly placed to its desgined location and then executes the Execute() method. I will not be covering Extends as we have a separate tutorial for it, now then lets move onto the execution of the script and how that works. function self:Execute() - this is out executer, the framework will first check all of the data from the expansions datatable, it is after the script is on the correct path, only then Execute() will be ran. Anything can be placed in the Execute() method, you can even do a PlayerAdded event which will then continue the script when a player joins! Client Trick - When a script is sent to run on a client, it will be placed in the playerGUI meaning you can do local player = script.Parent this will automatically get the player the script belongs to! Method 2 is currently in works and will not be ready till full release of 1.0.0! API Usage \u00b6 Just like any framework, Sunrise has its own API , this API uses other libraries to make Sunrise 10x better! In this section of the doc I will be teaching you how to use the API within your expansion in the correct way! Lets get started. First of all open the expansion you want to use the API in, if you haven't coded anything into this expansion and you got it using a template it should look similar to mine local self = { Name = \"test\", -- The name of the expansion LoaderVersion = \"1.0.0\", -- Version of the Framework Loader Path = \"Server\", -- \"Server\", \"Client\", or \"Both\" Extends = {} -- Extensions }; function self:Execute() -- Runs Automatically print(\"Hello World\"); end; return self; This is the same exact example like in the previous Expansion tutorial, remember even if you coded anything this will work the same! Lets get started with Example 1. First we need to decide what table to use. What is a table? A table is a section of the API, this section holds each function for that part of the API. You can see these at the start of each API section. It will look something like the following code, let me break it down for you. local API = self.API; local DataStore = API.DataStore; Ok lets start with self . This keyword is used to import things like the API from the loader, sounds confusing? Don't worry about this too much just know that it is used to get the API into your expansion. Now then in the first line what you are doing is casting the API into the API variable. In the second line we can see we use the variable API followed by DataStore now then what does this do? This will get all the functions from the DataStore table and cast it into the DataStore variable. Ok, for example 1 I will be using the Replica API table. local self = { Name = \"test\", LoaderVersion = \"1.0.0\", Path = \"Server\", Extends = {} }; function self:Execute() local API = self.API; --We get the API into the API variable local Replica = API.Replica; --We now cast the Replica table into the Replica variable Replica.new({data}) --We now call the API function for Replica, all of these can be found within the API reference! end; return self; Ok that is it for example 1, you can use any API function for Replica from just the Replica variable without having to worry about importing functions individually! This is not all however as there is also the client API, in the example above Replica is a SERVER ONLY table meaning you cannot use it on the client, however the method of getting the API has not changed! For example 2 we will be using a client table local self = { Name = \"test\", LoaderVersion = \"1.0.0\", Path = \"Client\", Extends = {} }; function self:Execute() local API = self.API; --This is exactly the same as the example above local icon = API.TopBar; --This gets the client Icon table icon.new({data}); --Use any function you want! end; return self; Bare in mind it is not recommended to use client tables in a server expansion! There is also the shared section which works exactly the same but can be safely used on both the client and server but I will not be getting into this! This is it for the API section! Framework usage example \u00b6","title":"Usage"},{"location":"Documentation/Usage/#expansion-usage","text":"In Sunrise Expansion are scripts which the Sunrise loader loads. Making expansions are very easy to add, it will also save your ServerScriptService from getting packed with scripts. Now how do you make expansions? There are 2 methods: The 1st method is doing the expansion manually, first you should know that only module scripts are accpeted by the loader anything else will be removed. First open your Sunrise framework It should look something like this, this is out-of-the-box look of Sunrise. As you can see there are a few things in the directory but we will only consentrate on Expansions . Anything in the expansion folder that is a Module Script with the native Sunrise format. Secondly create a module script script in the Expansions folder like and name it anything for simplicity I will name it test, you should have something like this: Great! Now then remember how I mentioned the Sunrise expansion format? Well now lets dive into that, open your expansion and copy and paste the following code into your expansion: local self = { Name = \"test\", -- The name of the expansion LoaderVersion = \"1.0.0\", -- Version of the Framework Loader Path = \"Server\", -- \"Server\", \"Client\", or \"Both\" Extends = {} -- Extensions }; function self:Execute() -- Runs Automatically print(\"Hello World\"); end; return self; Looks a bit complicated right? Well let me go through what everything does and get you up to speed, lets begin Lets go through the expansion datatable first as it is a very important part of the format Name - This is the name you want your expansion to be known as within the Sunrise runtime, each expansion will be regonised by the name you set in future updates. It is a good practice to set the name to the name you set the module script to, but hey its up to your preference! LoaderVersion - This as important as the Name , but why? When Sunrise framework is first initialized the loader reads all the expansions, if the LoaderVersion is not set to the same exact version as the loader then the expansion will simply be put into containment and ignored by the framework. Bare in mind that you do not have to use the exact version of the framework all you need is simply the 3 digits in my instance of it is 1.0.0 but in reality the version this tutorial is taken place is 1.0.0-alpha.1 Path - This is used to determine where your script will be ran. Sunrise loader does not load the script immediately, instead it first reads the Name , LoaderVersion and Path it is then correctly placed to its desgined location and then executes the Execute() method. I will not be covering Extends as we have a separate tutorial for it, now then lets move onto the execution of the script and how that works. function self:Execute() - this is out executer, the framework will first check all of the data from the expansions datatable, it is after the script is on the correct path, only then Execute() will be ran. Anything can be placed in the Execute() method, you can even do a PlayerAdded event which will then continue the script when a player joins! Client Trick - When a script is sent to run on a client, it will be placed in the playerGUI meaning you can do local player = script.Parent this will automatically get the player the script belongs to! Method 2 is currently in works and will not be ready till full release of 1.0.0!","title":"Expansion usage"},{"location":"Documentation/Usage/#api-usage","text":"Just like any framework, Sunrise has its own API , this API uses other libraries to make Sunrise 10x better! In this section of the doc I will be teaching you how to use the API within your expansion in the correct way! Lets get started. First of all open the expansion you want to use the API in, if you haven't coded anything into this expansion and you got it using a template it should look similar to mine local self = { Name = \"test\", -- The name of the expansion LoaderVersion = \"1.0.0\", -- Version of the Framework Loader Path = \"Server\", -- \"Server\", \"Client\", or \"Both\" Extends = {} -- Extensions }; function self:Execute() -- Runs Automatically print(\"Hello World\"); end; return self; This is the same exact example like in the previous Expansion tutorial, remember even if you coded anything this will work the same! Lets get started with Example 1. First we need to decide what table to use. What is a table? A table is a section of the API, this section holds each function for that part of the API. You can see these at the start of each API section. It will look something like the following code, let me break it down for you. local API = self.API; local DataStore = API.DataStore; Ok lets start with self . This keyword is used to import things like the API from the loader, sounds confusing? Don't worry about this too much just know that it is used to get the API into your expansion. Now then in the first line what you are doing is casting the API into the API variable. In the second line we can see we use the variable API followed by DataStore now then what does this do? This will get all the functions from the DataStore table and cast it into the DataStore variable. Ok, for example 1 I will be using the Replica API table. local self = { Name = \"test\", LoaderVersion = \"1.0.0\", Path = \"Server\", Extends = {} }; function self:Execute() local API = self.API; --We get the API into the API variable local Replica = API.Replica; --We now cast the Replica table into the Replica variable Replica.new({data}) --We now call the API function for Replica, all of these can be found within the API reference! end; return self; Ok that is it for example 1, you can use any API function for Replica from just the Replica variable without having to worry about importing functions individually! This is not all however as there is also the client API, in the example above Replica is a SERVER ONLY table meaning you cannot use it on the client, however the method of getting the API has not changed! For example 2 we will be using a client table local self = { Name = \"test\", LoaderVersion = \"1.0.0\", Path = \"Client\", Extends = {} }; function self:Execute() local API = self.API; --This is exactly the same as the example above local icon = API.TopBar; --This gets the client Icon table icon.new({data}); --Use any function you want! end; return self; Bare in mind it is not recommended to use client tables in a server expansion! There is also the shared section which works exactly the same but can be safely used on both the client and server but I will not be getting into this! This is it for the API section!","title":"API Usage"},{"location":"Documentation/Usage/#framework-usage-example","text":"","title":"Framework usage example"},{"location":"Documentation/Settings/Extends/","text":"","title":"Extends"},{"location":"Documentation/Settings/General/","text":"","title":"General"},{"location":"Documentation/Settings/UsingKnit/","text":"","title":"Knit"}]}